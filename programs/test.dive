/*
	{statement, 0, items in the following expression+1 (13) }
		{tuple, 0, 3} {"q", 0, 1} {"p", 1, 0}
		{colon, 3, 1}
		{tuple, 1, 3} {s64, 0, 1} {u64, 1, 0}
		{equal, 3, 1}
		{"bod", 1, 1}
		{tuple, 1, 0} {"O", 0, 1} {"P", 1, 0}
	{statement, 13, 2}
		{"one", 0, 0}
	{statement, 2, a lot}
		{"bod", 0, 1}
		{define, 1, 1}
		{parentheses, 1, amount of tokens in parentheses (18)}
			{statement, 0, 4}
				{"arg", 0, 1} {colon, 1, 1} {s64, 1, 0}
			{statement, 4, 4}
				{"aarg", 0, 1} {colon, 1, 1} {s64, 1, 0}
			{argseperator, 4, 1}
			{statement, 1, 0}
				{tuple, 0, 3} {"c", 0, 1} {"d", 1, 0}
				{colon, 1, 1}
				{tuple, 1, 0} {s64, 0, 1} {u64, 1, 0}
		{braces, 18, amount of tokens in braces}
			{statement, 0, etc} etc
			etc
			{statement, ?, }
				{"c", 0, 1}
				{equal, 1, 1}
				{parentheses, 1, 4}
					{"a", 0, 1}
					{mul, 1, 1}
					{"b", 1, 0}
				{add, 4, 1}
				{"ff", 1, 0}
*/
q, p: s64, u64 = bod O, P;
one;

bod :: (arg: s64; aarg: s64 -- c, d: s64, u64) {
	a, b: s64, s64 = 6, 34 + 44;
	ff :: 55;
	e: s64;
	place :: {
		c = a * b + ff; /* a * (b + ff) */
		c = (a * b) + ff;
		e = 1000 - c;
		if grows e, 0, place;
	}
	d = c as u64;
	return;
}

O, P :: -3, 100;

one :: () {
	thing: s32;
	thing = thing + -1;
	two :: {
		thing2: s64 = thing2 - 33;
	}
}

aaa, ppp: f64, ^f64;
ppp = &aaa;
aaa = ppp^;
ppp^ = aaa;

Thing :: struct (
	thing: f32;
	things: s64;
	ha: ptr;
);
